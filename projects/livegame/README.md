# Игра Жизнь

Прочитайте правила игры в [Википедии](https://ru.wikipedia.org/wiki/%D0%98%D0%B3%D1%80%D0%B0_%C2%AB%D0%96%D0%B8%D0%B7%D0%BD%D1%8C%C2%BB)

Наша вселенная будет состоять из ячеек HTML таблицы, которую мы динамически добавим в нашу веб-страницу. Это делается вызовом функции createUniverse при загрузке страницы.

Поскольку реализация этой функции связана со многими еще неизвестными вам понятиями, я уже создал функцию за вас. Все, что вам нужно сделать - это найти как сделать таблицу нужного вам размера. Сейчас она совсем маленькая - 3 x 3 ячейки. Поменяйте это на 20 x 20.

## Архитектура

![](https://github.com/gregzaitsev/school444/blob/master/projects/livegame/LiveGame.png)

## Создание модели

Разработайте модель данных для хранения состояния игры. Подумайте из каких переменных состоит состояние игры и создайте эти переменные в файле model.js.

Дальше нужно создать функцию перехода состояния на 1 шаг в соотвествии с правилами игры. Давайте назовем ее stateTransition. Подумайте какие циклы должна содержать эта функция, как сделать так, чтобы тело цикла выполнилось для каждого элемента в вашей модели состояния, а также как находить соседей этого элемента, чтобы выполнять правила игры. Еще не забудьте о том, что не у всех элементов есть 8 соседей. Некоторые находятся на краях поля (у них только 5 соседей), а некоторые по углам (у них вообще только три соседа).

## Отображение состояния

Для отображения состояния создайте функцию в файле viewmodel.js и вызовите ее для начала в конце функции createUniverse.

Подсказка: Чтобы проверить правильность работы этой функции, вручную заполните свою модель состояния сразу после ее инициализации, например вот так:

```
state[5][5] = 1;
```

и посмотрите изменится ли картинка при загрузке в браузер.

## Редактирование начального состояния

Чтобы игра была интересной, нужно разрешить пользователю редактировать начальное состояние. В коде уже есть функция tableClickHandler, которая вызывается когда пользователь нажимает на одну из ячеек таблицы. В параметрах эта функция получает событие ev, в котором можно найти идентифиактор ячейки, по которой кликнул пользователь вот так: `ev.srcElement.id`. Что нужно сделать в этой

## Запуск игры

Создайте кнопки "Start" и "Stop" в файле index.html. Задайте функции-обработчики события onclick для этих кнопок. Кнопка с обработчиком в HTML создается как показано ниже. Все, что нужно сделать Вам - это поменять название кнопки и выбрать правильное название для функции-обработчика и создать эту функцию в файле viewmodel.js (как - читайте дальше).

```
<button onclick="buttonclickhandler()">Button Name</button>
```

Создайте соответствующие функции-обработчики в файле viewmodel.js.

Обработчик кнопки Start должен запускать игру.

Ранее вы создали функцию изменения состояния. Допустим, она называется stateTransition. Вам нужно создать функцию выполнения одного шага игры вот так в файле viewmodel.js:

```
function gameStep() {
    stateTransition();
}
```

Теперь, после того как состояние изменено, его нужно отобразить. Допустим, вы назвали функцию прорисовки состояния drawState, ее нужно добавить в функцию `gameStep`, чтобы нарисовать новое состояние:
```
function gameStep() {
    stateTransition();
    drawState();
}
```

Теперь все, что осталось сделать - это зациклить вызов gameStep. Делается это при помощи таймера:

```
function gameStep() {
    stateTransition();
    drawState();

    setTimeout(gameStep, 1000);
}
```

Фунция setTimeout будет ждать 1000 миллисекунд, а затем вызовет функцию gameStep. Запомните этот прием программирования! Он называется рекурсией, потому что функция gameStep в итоге рекурсивно вызывает сама себя.

## Остановка игры

Придумайте самостоятельно как остановить игру. Подсказка - нужно использовать логическую переменную.
