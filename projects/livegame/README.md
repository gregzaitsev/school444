# Игра Жизнь

Прочитайте правила игры в [Википедии](https://ru.wikipedia.org/wiki/%D0%98%D0%B3%D1%80%D0%B0_%C2%AB%D0%96%D0%B8%D0%B7%D0%BD%D1%8C%C2%BB)

Наша вселенная будет состоять из ячеек HTML таблицы, которую мы динамически добавим в нашу веб-страницу. Это делается вызовом функции createUniverse при загрузке страницы.

Поскольку реализация этой функции связана со многими еще неизвестными вам понятиями, я уже создал функцию за вас. Все, что вам нужно сделать - это найти как сделать таблицу нужного вам размера. Сейчас она совсем маленькая - 3 x 3 ячейки. Поменяйте это на 20 x 20.

## Архитектура

![](https://github.com/gregzaitsev/school444/blob/master/projects/livegame/LiveGame.png)

## Создание модели

Разработайте модель данных для хранения состояния игры. Подумайте из каких переменных состоит состояние игры и создайте эти переменные в файле model.js.

Дальше нужно создать функцию перехода состояния на 1 шаг в соотвествии с правилами игры. Подумайте какие циклы должна содержать эта функция, как сделать так, чтобы тело цикла выполнилось для каждого элемента в вашей модели состояния, а также как найходить соседей этого элемента.

## Отображение состояния

Для отображения состояния создайте функцию в файле viewmodel.js и вызовите ее для начала в конце функции createUniverse.

Подсказка: Чтобы проверить правильность работы этой функции, вручную заполните свою модель состояния.


## Запуск игры

Создайте кнопки "Start" и "Stop" в файле index.html. Задайте функции-обработчики события onclick для этих кнопок.

Создайте соответствующие функции-обработчики в файле viewmodel.js.

Обработчик кнопки Start должен запускать игру.

Ранее вы создали функцию изменения состояния. Допустим, она называется stateTransition. Вам нужно создать функцию выполнения одного шага игры вот так в файле viewmodel.js:

```
function gameStep() {
    stateTransition();
}
```

Теперь, после того как состояние изменено, его нужно отобразить. Допустим, вы назвали функцию прорисовки состояния drawState, ее нужно добавить в функцию `gameStep`, чтобы нарисовать новое состояние:
```
function gameStep() {
    stateTransition();
    drawState();
}
```

Теперь все, что осталось сделать - это зациклить вызов gameStep. Делается это при помощи таймера:

```
function gameStep() {
    stateTransition();
    drawState();

    setTimeout(gameStep, 1000);
}
```

Фунция setTimeout будет ждать 1000 миллисекунд, а затем вызовет функцию gameStep. Запомните этот прием программирования! Он называется рекурсией, потому что функция gameStep в итоге рекурсивно вызывает сама себя.

## Остановка игры

Придумайте самостоятельно как остановить игру. Подсказка - нужно использовать логическую переменную.
